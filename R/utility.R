# SPDX-FileCopyrightText: 2023 Stephen Wade <stephematician@gmail.com>
# SPDX-License-Identifier: MIT

#' @importFrom rlang expr_deparse
#' @noRd
msg_if_not <- function(condition, msg=NULL)
    if (!condition) {
        if (is.null(msg)) rlang::expr_deparse(substitute(condition)) else msg
    }

#' Generate rows of a matrix sampled from the first `n` natural numbers.
#'
#' The rows returned by this function can be used to assign a sampler to each
#' case (with one or more missing values) when generating completed data sets
#' using the imputed values generated by [mimputest()]. Each column corresponds
#' to a (desired) completed dataset.
#'
#' This is an internal helper for [complete_by_sample()].
#'
#' In the case of non-replacement this function straightforwardly applies
#' `sample.int` to each row.  When sampling with replacement, the implementation
#' is a trivial call to `sample.int` over the entire matrix. The matrix will
#' have `size` rows (one for each case with one or more missing value), and `k`
#' columns (one for each desired completed data set).
#'
#' @param n integer (scalar): the number of samplers; each row of the matrix
#' will be samples from the set
#' \eqn{\{1, \ldots, n\}}{group('{', list(1, ..., n), '}')}.
#' @param k integer (scalar): the number of completed data sets that will be
#' generated and the number of columns in the output.
#' @param size integer (scalar): the number of observations with one or more
#' missing value and the number of rows in the output.
#' @param replace boolean (scalar): whether to sample with replacement or not.
#' @return matrix: A `size` by `k` matrix with each entry being a value between
#' 1 and `n` representing which sampler to take values from for each case (row)
#' and (desired) complete data set (column).
#'
#' @noRd
#' @md
row_sample_n <- function(n, k=n, size=0, replace=FALSE) {

    stopifnot(n >= 1 && k >= 1)
    stopifnot(k <= n)
    stopifnot(round(k) == k & round(n) == n)

    if (!replace && round(k) > 1) {
        matrix(sapply(rep_len(n, size), sample.int, size=k, replace=FALSE),
               byrow=TRUE,
               nrow=size)
    } else {
        matrix(sample.int(n, replace=TRUE, size=size * k), nrow=size)
    }

}


# Match the leaves that the missing cases belong to with those of predicted
# values, then draw once from the matching predicted values for each missing
# case.  See <https://github.com/amices/mice/blob/master/R/mice.impute.rf.R> for
# same procedure.
#' @importFrom stats predict
#' @noRd
predict_doove <- function(rf_fit, data, indicator, response) {

  # get the id's of the leaves for the observed and missing cases
    leaves <- predict(rf_fit,
                      newdata=data,
                      prediction_type='nodes')$nodes
    n_tree <- ncol(leaves)
    obs <- data[!indicator, response]

    donor_forest <- sapply(
        seq_len(n_tree),
        function(j) {
            unname(split(obs, leaves[!indicator, j])[
                as.character(leaves[indicator, j])
            ])
        }
    )
    if (sum(indicator) == 1) donor_forest %<>% array(dim=c(1, n_tree))
    apply(donor_forest, 1, function(s) sample(unlist(s), size=1, replace=TRUE))

}

