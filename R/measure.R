#' Measure correlation and stationary proportion between completed data sets
#'
#' Measures a relationship between two supplied completed data sets, typically
#' generated by two sequential iterations of the missForest procedure.
#' Given by the rank correlation or proportion of stationary values for
#' ordered (including continuous) and categorical data respectively.
#'
#' Measures a relationship between two supplied completed data sets, typically
#' generated by two sequential iterations of the missForest procedure. Intended
#' to be used with the stop criterion that as soon as all values (see below)
#' remain constant or decrease at once, then the missForest procedure is deemed
#' to have converged.
#'
#' The two values are the;
#' \itemize{
#'    \item mean rank correlation of the ordered (including continuous) data
#'          between the supplied completed data sets, and;
#'    \item proportion of stationary categorical data between the two supplied
#'          completed data sets (see \code{\link{stationary_rate}}).
#' }
#'
#' The type of correlation can be modified to that of \code{kendall} or
#' \code{pearson} (not recommended for ordered data) by the \code{method}
#' argument passed on to \code{\link[stats]{cor}}.
#'
#' @inheritParams sampler_loop
#' @param X named list;
#'            imputed values, in order of appearance by row in original data,
#'            of each variable (named) from one iteration within missForest
#'            procedure.
#' @param Y named list;
#'            imputed values, in order of appearance by row in origina data,
#'            of each variable (named) from the iteration within the missForest
#'            procedure succeeding that used to determine \code{X}.
#' @param method character;
#'            passed to \code{\link[stats]{cor}}.
#' @return named numeric;
#'             two named values: \describe{
#'                 \item{\code{continuous}}{mean (rank) correlation of the
#'                      continuous and ordered data between the two completed
#'                      data sets, and;}
#'                 \item{\code{categorical}}{proportion of stationary values of
#'                     categorical (unordered) data between the two completed
#'                     data sets (see \code{\link{stationary_rate}}).}
#'             }
#'
#' @seealso \code{\link[stats]{cor}} \code{\link{smirf}}
#'          \code{\link{stationary_rate}}
#'
#' @examples
#' \dontrun{
#' # simply pass to smirf
#' smirf(iris, stop.measure=measure_correlation)
#' }
#' @export
measure_correlation <- function(X, Y, X_init, indicator, method='spearman') {

    ordered <- categorical <- NULL

  # ordered includes continuous - use !! to convert to logical
    ordered_data <- names(X)[!sapply(X, is.factor) | !!sapply(X, is.ordered)]

    categorical_data <- setdiff(names(X), ordered_data)

    if (length(ordered_data) > 0)
        ordered <- mean(mapply(function(x, y, d, indicator)
                               cor(xtfrm(c(x, d[!indicator])),
                                   xtfrm(c(y, d[!indicator])),
                                   method=method),
                               X[ordered_data],
                               Y[ordered_data],
                               X_init[ordered_data],
                               indicator[ordered_data]))

    if (length(categorical_data) > 0)
        categorical <- stationary_rate(X[categorical_data],
                                       Y[categorical_data],
                                       X_init[categorical_data],
                                       indicator[categorical_data])

    c(categorical=categorical, ordered=ordered)

}


#' Measure if reached limit of iterations
#'
#' A degenerate 'measure' of convergence, which simply returns whether to
#' continue if the limit of the number of iterations has been reached, or not.
#'
#' @inheritParams perform_missforest
#' @param X named list;
#'            imputed values, in order of appearance by row in original data,
#'            of each variable (named) from one iteration within missForest
#'            procedure.
#' @param Y named list;
#'            imputed values, in order of appearance by row in origina data,
#'            of each variable (named) from the iteration within the missForest
#'            procedure succeeding that used to determine \code{X}.
#' @param env environment;
#'            environment of the calling function
#'            \code{\link{perform_missforest}}
#' @return named numeric;
#'             zero when the limit on number of iterations has been reached,
#'             otherwise the current iteration.
#'
#' @seealso \code{\link{smirf}}
#'
#' @examples
#' \dontrun{
#' # simply pass to smirf
#' smirf(iris, stop.measure=measure_degenerate)
#' }
#' @export
measure_degenerate <- function(X, Y, X_init, indicator, env=parent.frame()) {

    if (eval(expression(loop_limit < 2L), envir=env)) {
        NULL
    } else
        c(measure=eval(expression(j * (j < loop_limit)), envir=env))

}


#' Measure change between completed data sets as per Stekhoven and Buehlmann
#'
#' Measures a relationship between two supplied completed data sets, typically
#' generated by two sequential iterations of the missForest procedure. Given by
#' a Frobenius norm-based relative difference or the proportion of stationary
#' values for continuous and categorical (included ordered) data respectively,
#' as in Stekhoven and Buehlmann (2012).
#'
#' Measures a relationship between two supplied completed data sets, typically
#' generated by two sequential iterations of the missForest procedure. Intended
#' to be used with the stop criterion that as soon as all values (see below)
#' remain constant or decrease at once, then the missForest procedure is deemed
#' to have converged. These are as per the original Stekhoven and Buehlmann
#' (2012) paper.
#'
#' The two measures are the;
#' \itemize{
#'    \item sum of the differences squared of all continuous data divided by the
#'          sum of the squares of the continuous data in the second supplied
#'          completed data set, and;
#'    \item proportion of stationary categorical data between the two supplied
#'          completed data sets (see \code{\link{stationary_rate}}).
#' }
#'
#' The first item is referred to here as a Frobenius norm-based relative
#' difference in the completed data.
#'
#' @inheritParams perform_missforest
#' @param X named list;
#'            imputed values of each variable (named) from one iteration within
#'            missForest procedure.
#' @param Y list;
#'            imputed values of each variable (named) from the iteration within
#'            the missForest procedure succeeding that used to determine
#'            \code{X}.
#' @return named numeric;
#'             two named values: \describe{
#'                 \item{\code{continuous}}{a Frobenius normi-based relative
#'                      difference of the continuous data between the two
#'                      completed data sets, and;}
#'                 \item{\code{categorical}}{proportion of stationary values of
#'                     categorical (including ordered) data between the two
#'                     completed data sets (see \code{\link{stationary_rate}}).}
#'             }
#'
#' @seealso \code{\link{measure_correlation}} \code{\link{smirf}}
#'          \code{\link{stationary_rate}}
#'
#' @references
#'
#' Stekhoven, D.J. and Buehlmann, P., 2012. MissForest--non-parametric missing
#' value imputation for mixed-type data. \emph{Bioinformatics, 28}(1), pp.
#' 112-118.
#' \href{https://dx.doi.org/10.1093/bioinformatics/btr597}{doi.1.1093/bioinformatics/btr597}
#'
#' @examples
#' \dontrun{
#' # simply pass to smirf
#' smirf(iris, stop.measure=measure_stekhoven_2012)
#' }
#' @export
measure_stekhoven_2012 <- function(X, Y, X_init, indicator) {

    continuous <- categorical <- NULL

    cts_data <- names(X)[!sapply(X, is.factor)]

    # includes ordered data
    cat_data <- setdiff(names(X), cts_data)

    # reversed sign here due to form of stop_condition()
    if (length(cts_data) > 0)
        continuous <- -sum(mapply(function(x, y) sum((x - y)^2),
                                  X[cts_data],
                                  Y[cts_data])) /
                           sum(mapply(function(x, d, indicator)
                                          sum(c(x, d[!indicator])^2),
                                      Y[cts_data],
                                      X_init[cts_data],
                                      indicator[cts_data]))

    if (length(cat_data) > 0)
        categorical <- stationary_rate(X[cat_data],
                                       Y[cat_data],
                                       X_init[cat_data],
                                       indicator[cat_data])

    c(categorical=categorical, continuous=continuous)

}

